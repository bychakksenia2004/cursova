{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///D:/magistrature/Dockerwork/kursova/lib/mongodb.ts"],"sourcesContent":["import mongoose from \"mongoose\";\r\nimport dns from \"dns/promises\";\r\n\r\n// Додаємо константу з fallback на MONGODB_URI\r\nconst MONGODB_URL = process.env.MONGODB_URL || process.env.MONGODB_URI;\r\n\r\nif (!MONGODB_URL) {\r\n  throw new Error(\"❌ Вкажи змінну MONGODB_URL або MONGODB_URI у .env.local\");\r\n}\r\n\r\nlet cached = (global as any).mongoose;\r\n\r\nif (!cached) {\r\n  cached = (global as any).mongoose = { conn: null, promise: null };\r\n}\r\n\r\nexport async function connectToDB(): Promise<typeof mongoose> {\r\n  if (cached.conn) return cached.conn;\r\n\r\n  if (!cached.promise) {\r\n    // Більші таймаути для більш стабільної діагностики\r\n    cached.promise = mongoose\r\n      .connect(MONGODB_URL as string, {\r\n        // сучасні mongoose/driver опції за замовчуванням працюють добре,\r\n        // але додаємо час очікування на вибір сервера для швидшої діагностики\r\n        serverSelectionTimeoutMS: 10000,\r\n        connectTimeoutMS: 10000,\r\n        socketTimeoutMS: 45000\r\n      })\r\n      .then((mongoose) => mongoose)\r\n      .catch(async (err) => {\r\n        // Лог оригінальної помилки на сервері (щоб бачити стек)\r\n        console.error(\"MongoDB connection error (original):\", err);\r\n\r\n        // Базове дружнє повідомлення\r\n        let diag = [\r\n          \"Не вдалося підключитися до MongoDB.\",\r\n          \"Перевірте MONGODB_URL у d:\\\\magistrature\\\\Dockerwork\\\\kursova\\\\.env.local,\",\r\n          \"переконайтесь, що кластер працює, та що ваш IP добавлений в Network Access (whitelist) в Atlas.\",\r\n          `Оригінальна помилка: ${err?.message ?? String(err)}`\r\n        ].join(\" \");\r\n\r\n        // Додаткова діагностика для mongodb+srv (DNS SRV)\r\n        try {\r\n          if (typeof MONGODB_URL === \"string\" && MONGODB_URL.startsWith(\"mongodb+srv://\")) {\r\n            try {\r\n              const parsed = new URL(MONGODB_URL);\r\n              const host = parsed.hostname;\r\n              diag += ` SRV host: ${host}.`;\r\n\r\n              try {\r\n                const srv = await dns.resolveSrv(`_mongodb._tcp.${host}`);\r\n                diag += ` DNS SRV records: ${JSON.stringify(srv)}.`;\r\n              } catch (srvErr) {\r\n                diag += ` DNS SRV lookup failed: ${srvErr?.message ?? String(srvErr)}.`;\r\n              }\r\n\r\n              try {\r\n                const lookup = await dns.lookup(host);\r\n                diag += ` DNS lookup: ${JSON.stringify(lookup)}.`;\r\n              } catch (lookupErr) {\r\n                diag += ` DNS lookup failed: ${lookupErr?.message ?? String(lookupErr)}.`;\r\n              }\r\n            } catch (parseErr) {\r\n              diag += ` Failed to parse URL for additional diagnostics: ${parseErr?.message ?? String(parseErr)}.`;\r\n            }\r\n          } else {\r\n            // Для звичайних mongodb:// хостів також можна зробити dns.lookup\r\n            try {\r\n              const parsed = new URL(MONGODB_URL as string);\r\n              const host = parsed.hostname;\r\n              try {\r\n                const lookup = await dns.lookup(host);\r\n                diag += ` DNS lookup: ${JSON.stringify(lookup)}.`;\r\n              } catch (lookupErr) {\r\n                diag += ` DNS lookup failed: ${lookupErr?.message ?? String(lookupErr)}.`;\r\n              }\r\n            } catch {\r\n              // нічого\r\n            }\r\n          }\r\n        } catch (diagErr) {\r\n          diag += ` (diagnostics failed: ${diagErr?.message ?? String(diagErr)})`;\r\n        }\r\n\r\n        // Кидаємо нову помилку з детальною діагностикою\r\n        throw new Error(diag);\r\n      });\r\n  }\r\n\r\n  cached.conn = await cached.promise;\r\n  return cached.conn;\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,8CAA8C;AAC9C,MAAM,cAAc,QAAQ,GAAG,CAAC,WAAW,IAAI,QAAQ,GAAG,CAAC,WAAW;AAEtE,IAAI,CAAC,aAAa;IAChB,MAAM,IAAI,MAAM;AAClB;AAEA,IAAI,SAAS,yDAAgB,QAAQ;AAErC,IAAI,CAAC,QAAQ;IACX,SAAS,yDAAgB,QAAQ,GAAG;QAAE,MAAM;QAAM,SAAS;IAAK;AAClE;AAEO,eAAe;IACpB,IAAI,OAAO,IAAI,EAAE,OAAO,OAAO,IAAI;IAEnC,IAAI,CAAC,OAAO,OAAO,EAAE;QACnB,mDAAmD;QACnD,OAAO,OAAO,GAAG,oHAAQ,CACtB,OAAO,CAAC,aAAuB;YAC9B,iEAAiE;YACjE,sEAAsE;YACtE,0BAA0B;YAC1B,kBAAkB;YAClB,iBAAiB;QACnB,GACC,IAAI,CAAC,CAAC,WAAa,UACnB,KAAK,CAAC,OAAO;YACZ,wDAAwD;YACxD,QAAQ,KAAK,CAAC,wCAAwC;YAEtD,6BAA6B;YAC7B,IAAI,OAAO;gBACT;gBACA;gBACA;gBACA,CAAC,qBAAqB,EAAE,KAAK,WAAW,OAAO,MAAM;aACtD,CAAC,IAAI,CAAC;YAEP,kDAAkD;YAClD,IAAI;gBACF,IAAI,OAAO,gBAAgB,YAAY,YAAY,UAAU,CAAC,mBAAmB;oBAC/E,IAAI;wBACF,MAAM,SAAS,IAAI,IAAI;wBACvB,MAAM,OAAO,OAAO,QAAQ;wBAC5B,QAAQ,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC;wBAE7B,IAAI;4BACF,MAAM,MAAM,MAAM,kIAAG,CAAC,UAAU,CAAC,CAAC,cAAc,EAAE,MAAM;4BACxD,QAAQ,CAAC,kBAAkB,EAAE,KAAK,SAAS,CAAC,KAAK,CAAC,CAAC;wBACrD,EAAE,OAAO,QAAQ;4BACf,QAAQ,CAAC,wBAAwB,EAAE,QAAQ,WAAW,OAAO,QAAQ,CAAC,CAAC;wBACzE;wBAEA,IAAI;4BACF,MAAM,SAAS,MAAM,kIAAG,CAAC,MAAM,CAAC;4BAChC,QAAQ,CAAC,aAAa,EAAE,KAAK,SAAS,CAAC,QAAQ,CAAC,CAAC;wBACnD,EAAE,OAAO,WAAW;4BAClB,QAAQ,CAAC,oBAAoB,EAAE,WAAW,WAAW,OAAO,WAAW,CAAC,CAAC;wBAC3E;oBACF,EAAE,OAAO,UAAU;wBACjB,QAAQ,CAAC,iDAAiD,EAAE,UAAU,WAAW,OAAO,UAAU,CAAC,CAAC;oBACtG;gBACF,OAAO;oBACL,iEAAiE;oBACjE,IAAI;wBACF,MAAM,SAAS,IAAI,IAAI;wBACvB,MAAM,OAAO,OAAO,QAAQ;wBAC5B,IAAI;4BACF,MAAM,SAAS,MAAM,kIAAG,CAAC,MAAM,CAAC;4BAChC,QAAQ,CAAC,aAAa,EAAE,KAAK,SAAS,CAAC,QAAQ,CAAC,CAAC;wBACnD,EAAE,OAAO,WAAW;4BAClB,QAAQ,CAAC,oBAAoB,EAAE,WAAW,WAAW,OAAO,WAAW,CAAC,CAAC;wBAC3E;oBACF,EAAE,OAAM;oBACN,SAAS;oBACX;gBACF;YACF,EAAE,OAAO,SAAS;gBAChB,QAAQ,CAAC,sBAAsB,EAAE,SAAS,WAAW,OAAO,SAAS,CAAC,CAAC;YACzE;YAEA,gDAAgD;YAChD,MAAM,IAAI,MAAM;QAClB;IACJ;IAEA,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;IAClC,OAAO,OAAO,IAAI;AACpB"}},
    {"offset": {"line": 149, "column": 0}, "map": {"version":3,"sources":["file:///D:/magistrature/Dockerwork/kursova/lib/models/Test.ts"],"sourcesContent":["import mongoose, { Document, Model } from \"mongoose\";\r\n\r\n// TypeScript interfaces for question variants\r\ntype QBase = {\r\n  id: number;\r\n  type: \"single_choice\" | \"multi_choice\" | \"sequence\" | \"matching\" | \"open\";\r\n  text: string;\r\n  imageUrl?: string;\r\n};\r\n\r\ntype SingleOption = { id: number; text: string; correct: boolean };\r\ntype SequenceItem = { id: number; text: string; order: number };\r\ntype PairItem = { id: number; left: string; right: string };\r\n\r\nexport type SingleQuestion = QBase & { type: \"single_choice\"; options: SingleOption[] };\r\nexport type MultiQuestion = QBase & { type: \"multi_choice\"; options: SingleOption[] };\r\nexport type SequenceQuestion = QBase & { type: \"sequence\"; options: SequenceItem[] };\r\nexport type MatchingQuestion = QBase & { type: \"matching\"; pairs: PairItem[] };\r\nexport type OpenQuestion = QBase & { type: \"open\"; answers: string[] };\r\n\r\nexport interface ITest extends Document {\r\n  title: string;\r\n  description: string | null;\r\n  authorId: mongoose.Types.ObjectId;\r\n  visibility: \"private\" | \"public\";\r\n  storeResponses: boolean;\r\n  ownResultView: \"full\" | \"score_only\" | \"nothing\";\r\n  timed?: boolean;\r\n  timeLimitMinutes?: number | null;\r\n  dateWindowEnabled?: boolean;\r\n  openFrom?: Date | null;\r\n  openTo?: Date | null;\r\n  questions: Array<SingleQuestion | MultiQuestion | SequenceQuestion | MatchingQuestion | OpenQuestion>;\r\n}\r\n\r\n// Mongoose sub-schemas\r\nconst questionOpts = { discriminatorKey: \"type\", _id: false } as const;\r\n\r\nconst BaseQuestionSchema = new mongoose.Schema(\r\n  {\r\n    id: { type: Number, required: true },\r\n    type: { type: String, required: true },\r\n    text: { type: String, required: true },\r\n    imageUrl: { type: String, required: false },\r\n  },\r\n  questionOpts\r\n);\r\n\r\nconst SingleQuestionSchema = new mongoose.Schema(\r\n  {\r\n    options: [\r\n      {\r\n        id: { type: Number, required: true },\r\n        text: { type: String, required: true },\r\n        correct: { type: Boolean, required: true },\r\n      },\r\n    ],\r\n  },\r\n  { _id: false }\r\n);\r\n\r\nconst MultiQuestionSchema = new mongoose.Schema(\r\n  {\r\n    options: [\r\n      {\r\n        id: { type: Number, required: true },\r\n        text: { type: String, required: true },\r\n        correct: { type: Boolean, required: true },\r\n      },\r\n    ],\r\n  },\r\n  { _id: false }\r\n);\r\n\r\nconst SequenceQuestionSchema = new mongoose.Schema(\r\n  {\r\n    options: [\r\n      {\r\n        id: { type: Number, required: true },\r\n        text: { type: String, required: true },\r\n        order: { type: Number, required: true },\r\n      },\r\n    ],\r\n  },\r\n  { _id: false }\r\n);\r\n\r\nconst MatchingQuestionSchema = new mongoose.Schema(\r\n  {\r\n    pairs: [\r\n      {\r\n        id: { type: Number, required: true },\r\n        left: { type: String, required: true },\r\n        right: { type: String, required: true },\r\n      },\r\n    ],\r\n  },\r\n  { _id: false }\r\n);\r\n\r\nconst OpenQuestionSchema = new mongoose.Schema(\r\n  {\r\n    answers: [\r\n      {\r\n        type: String,\r\n      },\r\n    ],\r\n  },\r\n  { _id: false }\r\n);\r\n\r\n// Main Test schema — questions array uses base schema and will be discriminated\r\nconst TestSchema = new mongoose.Schema<ITest>(\r\n  {\r\n    title: { type: String, required: true },\r\n    description: { type: String, required: false },\r\n    authorId: { type: mongoose.Schema.Types.ObjectId, required: true, ref: \"User\" },\r\n    visibility: { type: String, enum: [\"private\", \"public\"], default: \"private\" },\r\n    storeResponses: { type: Boolean, default: false },\r\n    ownResultView: { type: String, enum: [\"full\", \"score_only\", \"nothing\"], default: \"full\" },\r\n    timed: { type: Boolean, default: false },\r\n    timeLimitMinutes: { type: Number, required: false },\r\n    dateWindowEnabled: { type: Boolean, default: false },\r\n    openFrom: { type: Date, required: false },\r\n    openTo: { type: Date, required: false },\r\n    questions: [BaseQuestionSchema],\r\n  }\r\n);\r\n\r\n// Apply discriminators for the question array\r\n// Note: for array discriminators use TestSchema.path('questions').discriminator(...)\r\n;(TestSchema.path(\"questions\") as any).discriminator(\"single_choice\", SingleQuestionSchema as any);\r\n;(TestSchema.path(\"questions\") as any).discriminator(\"multi_choice\", MultiQuestionSchema as any);\r\n;(TestSchema.path(\"questions\") as any).discriminator(\"sequence\", SequenceQuestionSchema as any);\r\n;(TestSchema.path(\"questions\") as any).discriminator(\"matching\", MatchingQuestionSchema as any);\r\n;(TestSchema.path(\"questions\") as any).discriminator(\"open\", OpenQuestionSchema as any);\r\n\r\nconst Test: Model<ITest> = mongoose.models.Test || mongoose.model<ITest>(\"Test\", TestSchema);\r\nexport default Test;"],"names":[],"mappings":"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"}},
    {"offset": {"line": 338, "column": 0}, "map": {"version":3,"sources":["file:///D:/magistrature/Dockerwork/kursova/app/api/public-tests/%5Bid%5D/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\r\nimport { connectToDB } from \"../../../../lib/mongodb\";\r\nimport Test from \"../../../../lib/models/Test\";\r\n\r\nexport async function GET(req: Request, ctx: any) {\r\n  try {\r\n    const params = await ctx.params;\r\n    const id = params?.id;\r\n    if (!id) return NextResponse.json({ error: \"Missing id\" }, { status: 400 });\r\n    await connectToDB();\r\n    const test = await Test.findById(String(id)).populate({ path: \"authorId\", select: \"username\" }).lean();\r\n    if (!test) return NextResponse.json({ error: \"Not found\" }, { status: 404 });\r\n    if (test.visibility !== \"public\") return NextResponse.json({ error: \"Not public\" }, { status: 403 });\r\n\r\n    return NextResponse.json({ ok: true, test }, { status: 200 });\r\n  } catch (err: any) {\r\n    console.error(\"/api/public-tests/[id] GET error:\", err);\r\n    return NextResponse.json({ error: err?.message || String(err) }, { status: 500 });\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEO,eAAe,IAAI,GAAY,EAAE,GAAQ;IAC9C,IAAI;QACF,MAAM,SAAS,MAAM,IAAI,MAAM;QAC/B,MAAM,KAAK,QAAQ;QACnB,IAAI,CAAC,IAAI,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAa,GAAG;YAAE,QAAQ;QAAI;QACzE,MAAM,IAAA,+HAAW;QACjB,MAAM,OAAO,MAAM,kIAAI,CAAC,QAAQ,CAAC,OAAO,KAAK,QAAQ,CAAC;YAAE,MAAM;YAAY,QAAQ;QAAW,GAAG,IAAI;QACpG,IAAI,CAAC,MAAM,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAY,GAAG;YAAE,QAAQ;QAAI;QAC1E,IAAI,KAAK,UAAU,KAAK,UAAU,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAa,GAAG;YAAE,QAAQ;QAAI;QAElG,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,IAAI;YAAM;QAAK,GAAG;YAAE,QAAQ;QAAI;IAC7D,EAAE,OAAO,KAAU;QACjB,QAAQ,KAAK,CAAC,qCAAqC;QACnD,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO,KAAK,WAAW,OAAO;QAAK,GAAG;YAAE,QAAQ;QAAI;IACjF;AACF"}}]
}