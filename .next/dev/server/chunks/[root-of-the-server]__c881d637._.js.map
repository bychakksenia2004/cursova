{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///D:/magistrature/Dockerwork/kursova/lib/mongodb.ts"],"sourcesContent":["import mongoose from \"mongoose\";\r\n\r\n// Додаємо константу з fallback на MONGODB_URI\r\nconst MONGODB_URL = process.env.MONGODB_URL || process.env.MONGODB_URI;\r\n\r\nif (!MONGODB_URL) {\r\n  throw new Error(\"❌ Вкажи змінну MONGODB_URL або MONGODB_URI у .env.local\");\r\n}\r\n\r\nlet cached = (global as any).mongoose;\r\n\r\nif (!cached) {\r\n  cached = (global as any).mongoose = { conn: null, promise: null };\r\n}\r\n\r\nexport async function connectToDB(): Promise<typeof mongoose> {\r\n  if (cached.conn) return cached.conn;\r\n\r\n  if (!cached.promise) {\r\n    // додаємо таймаут на вибір сервера та ловимо помилки, щоб дати більш корисний меседж\r\n    cached.promise = mongoose\r\n      .connect(MONGODB_URL as string, { serverSelectionTimeoutMS: 5000 })\r\n      .then((mongoose) => mongoose)\r\n      .catch((err) => {\r\n        // Зберігаємо оригінальну помилку в логах і кидаємо дружнє повідомлення\r\n        console.error(\"MongoDB connection error:\", err);\r\n        throw new Error(\r\n          \"Не вдалося підключитися до MongoDB. Причини: неправильний MONGODB_URL, мережеві проблеми або IP не доданий до whitelist в MongoDB Atlas. \" +\r\n            \"Перевірте значення MONGODB_URL у d:\\\\magistrature\\\\Dockerwork\\\\kursova\\\\.env.local, \" +\r\n            \"додайте ваш IP або 0.0.0.0/0 в Atlas Network Access (тільки для dev), і перезапустіть dev-сервер. \" +\r\n            `Оригінальна помилка: ${err.message}`\r\n        );\r\n      });\r\n  }\r\n\r\n  cached.conn = await cached.promise;\r\n  return cached.conn;\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,8CAA8C;AAC9C,MAAM,cAAc,QAAQ,GAAG,CAAC,WAAW,IAAI,QAAQ,GAAG,CAAC,WAAW;AAEtE,IAAI,CAAC,aAAa;IAChB,MAAM,IAAI,MAAM;AAClB;AAEA,IAAI,SAAS,yDAAgB,QAAQ;AAErC,IAAI,CAAC,QAAQ;IACX,SAAS,yDAAgB,QAAQ,GAAG;QAAE,MAAM;QAAM,SAAS;IAAK;AAClE;AAEO,eAAe;IACpB,IAAI,OAAO,IAAI,EAAE,OAAO,OAAO,IAAI;IAEnC,IAAI,CAAC,OAAO,OAAO,EAAE;QACnB,qFAAqF;QACrF,OAAO,OAAO,GAAG,oHAAQ,CACtB,OAAO,CAAC,aAAuB;YAAE,0BAA0B;QAAK,GAChE,IAAI,CAAC,CAAC,WAAa,UACnB,KAAK,CAAC,CAAC;YACN,uEAAuE;YACvE,QAAQ,KAAK,CAAC,6BAA6B;YAC3C,MAAM,IAAI,MACR,8IACE,yFACA,uGACA,CAAC,qBAAqB,EAAE,IAAI,OAAO,EAAE;QAE3C;IACJ;IAEA,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;IAClC,OAAO,OAAO,IAAI;AACpB"}},
    {"offset": {"line": 95, "column": 0}, "map": {"version":3,"sources":["file:///D:/magistrature/Dockerwork/kursova/lib/models/User.ts"],"sourcesContent":["import mongoose, { Document, Model } from \"mongoose\";\r\n\r\nexport interface IUser extends Document {\r\n  username: string;\r\n  email: string;\r\n  password: string;\r\n}\r\n\r\nconst UserSchema = new mongoose.Schema<IUser>(\r\n  {\r\n    email: { type: String, required: true, unique: true },\r\n    username: { type: String, required: true },\r\n    password: { type: String, required: true }\r\n  }\r\n);\r\n\r\nconst User: Model<IUser> = mongoose.models.User || mongoose.model<IUser>(\"User\", UserSchema);\r\nexport default User;\r\n"],"names":[],"mappings":";;;;AAAA;;AAQA,MAAM,aAAa,IAAI,oHAAQ,CAAC,MAAM,CACpC;IACE,OAAO;QAAE,MAAM;QAAQ,UAAU;QAAM,QAAQ;IAAK;IACpD,UAAU;QAAE,MAAM;QAAQ,UAAU;IAAK;IACzC,UAAU;QAAE,MAAM;QAAQ,UAAU;IAAK;AAC3C;AAGF,MAAM,OAAqB,oHAAQ,CAAC,MAAM,CAAC,IAAI,IAAI,oHAAQ,CAAC,KAAK,CAAQ,QAAQ;uCAClE"}},
    {"offset": {"line": 122, "column": 0}, "map": {"version":3,"sources":["file:///D:/magistrature/Dockerwork/kursova/app/api/register/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\r\nimport bcrypt from \"bcryptjs\";\r\nimport { connectToDB } from \"../../../lib/mongodb\";\r\nimport User from \"../../../lib/models/User\";\r\n\r\nexport async function POST(req: Request) {\r\n  try {\r\n    const body = await req.json();\r\n    const { email, username, password } = body || {};\r\n\r\n    if (!email || !username || !password) {\r\n      return NextResponse.json({ error: \"Missing fields\" }, { status: 400 });\r\n    }\r\n\r\n    await connectToDB();\r\n\r\n    const existing = await User.findOne({\r\n      $or: [{ email: email.toLowerCase() }, { username }]\r\n    }).lean();\r\n\r\n    if (existing) {\r\n      return NextResponse.json({ error: \"User with given email or username already exists\" }, { status: 409 });\r\n    }\r\n\r\n    const passwordHash = await bcrypt.hash(password, 10);\r\n\r\n    const created = await User.create({\r\n      email: email.toLowerCase(),\r\n      username,\r\n      passwordHash\r\n    });\r\n\r\n    return NextResponse.json({ ok: true, id: created._id }, { status: 201 });\r\n  } catch (err) {\r\n    console.error(\"Register error:\", err);\r\n    return NextResponse.json({ error: \"Internal server error\" }, { status: 500 });\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEO,eAAe,KAAK,GAAY;IACrC,IAAI;QACF,MAAM,OAAO,MAAM,IAAI,IAAI;QAC3B,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,GAAG,QAAQ,CAAC;QAE/C,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,UAAU;YACpC,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAiB,GAAG;gBAAE,QAAQ;YAAI;QACtE;QAEA,MAAM,IAAA,+HAAW;QAEjB,MAAM,WAAW,MAAM,kIAAI,CAAC,OAAO,CAAC;YAClC,KAAK;gBAAC;oBAAE,OAAO,MAAM,WAAW;gBAAG;gBAAG;oBAAE;gBAAS;aAAE;QACrD,GAAG,IAAI;QAEP,IAAI,UAAU;YACZ,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAmD,GAAG;gBAAE,QAAQ;YAAI;QACxG;QAEA,MAAM,eAAe,MAAM,8IAAM,CAAC,IAAI,CAAC,UAAU;QAEjD,MAAM,UAAU,MAAM,kIAAI,CAAC,MAAM,CAAC;YAChC,OAAO,MAAM,WAAW;YACxB;YACA;QACF;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,IAAI;YAAM,IAAI,QAAQ,GAAG;QAAC,GAAG;YAAE,QAAQ;QAAI;IACxE,EAAE,OAAO,KAAK;QACZ,QAAQ,KAAK,CAAC,mBAAmB;QACjC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAwB,GAAG;YAAE,QAAQ;QAAI;IAC7E;AACF"}}]
}